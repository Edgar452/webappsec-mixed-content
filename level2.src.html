<h1>Mixed Content Level 2</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec-mixed-content/level2.html
Shortname: mixed-content-2
Level: 2
Editor: Emily Stark, Google Inc., estark@google.com
        Mike West, Google Inc., mkwst@google.com
Group: webappsec
Abstract:
  This specification describes how a user agent should handle fetching of
  content over unencrypted or unauthenticated connections in the context of an
  encrypted and authenticated document.
Version History: https://github.com/w3c/webappsec-mixed-content/commits/master/level2.src.html
Boilerplate: omit conformance, omit feedback-header
!Participate: <a href="https://github.com/w3c/webappsec-mixed-content/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-mixed-content/issues">open issues</a>)
!Feedback: <a href="https://github.com/w3c/webappsec-mixed-content/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-mixed-content/issues">open issues</a>)
Indent: 2
Markup Shorthands: markdown on
Boilerplate: omit conformance, omit feedback-header
</pre>
<!--
    HTML Definitions
-->
<pre class="link-defaults">
spec:html; type:dfn; for:/; text: use srcset or picture
spec:html; type:dfn; for:/; text:browsing context
spec:html; type:dfn; for:/; text:plugin
spec:html; type:dfn; for:/; text:global object
spec:fetch; type:dfn; for:/; text:request
spec:fetch; type:dfn; for:/; text:response
spec:dom; type:interface; text:Document
</pre>
<pre class="anchors">
type: dfn
  urlPrefix: https://tools.ietf.org/html/rfc6797
    text: mixed security context; url: section-12.4
type: dfn
  urlPrefix: https://tools.ietf.org/html/rfc6455; spec: RFC6455
    text: fail the websocket connection; url: section-7.1.7
type: attribute
  text: onerror; for: WebSocket; url: https://www.w3.org/TR/websockets/#handler-websocket-onerror
</pre>

<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  When a user successfully loads a webpage from <code>example.com</code> over a
  secure channel (HTTPS, for example), the user is guaranteed that no entity
  between the user agent and <code>example.com</code> eavesdropped on or
  tampered with the data transmitted between them. However, this guarantee is
  weakened if the webpage loads subresources such as script or images over an
  insecure connection. For example, an insecurely-loaded script can allow an
  attacker to read or modify data on behalf of the user. An insecurely-loaded
  image can allow an attacker to communicate incorrect information to the user
  (e.g., a fabricated stock chart), mutate client-side state (e.g., set a
  cookie), or induce the user to take an unintended action (e.g., changing the
  label on a button). These requests are known as mixed content.

  [[!MIXED-CONTENT]] details how a user agent can mitigate these risks by
  blocking certain types of mixed content, and behaving more strictly in some
  contexts.

  However, as implemented in today's web browsers, [[!MIXED-CONTENT]] does not fully protect the
  confidentiality and integrity of users' data. Insecure content such as images, audio, and video
  can currently be loaded by default in secure contexts.

  Moreover, users do not have a clear security indicator when mixed content is loaded. When a
  webpage loads mixed content, browsers display an "in-between" security indicator (such as removing
  the padlock icon), which does not give users a clear indication of whether they should trust the
  page. This UX has also not proved a sufficient incentive for developers to avoid mixed content,
  since it is still common for webpages to load mixed content. Blocking all mixed content would
  provide the user with a simpler mental model -- the webpage is either loaded over a secure
  transport or it isn't -- and encourage developers to securely load any mixed content that is
  necessary for their webpage to function properly.

  Mixed Content Level 2 therefore updates and extends [[!MIXED-CONTENT]] to provide users with
  better security and privacy guarantees and a better security UX, while minimizing
  breakage. Instead of advising browsers to simply strictly block all mixed content, the core idea
  of Level 2 is <i>mixed content autoupgrading</i>. That is, mixed content that user agents are not
  already blocking should be autoupgraded to a secure transport. If the request cannot be
  autoupgraded, it will be blocked. Autoupgrading avoids loading insecure resources on secure
  webpages, while minimizing the amount of developer effort needed to avoid breakage.

  This specification (Level 2) only recommends autoupgrading types of mixed content that are not
  currently blocked by default, and does not recommend autougprading types of content that are
  already blocked. This is to minimize the amount of web-visible change; we only want to autoupgrade
  content if it advances us towards the goal of blocking all mixed content by default.
</section>

<section>
  <h2 id="terms">Key Concepts and Terminology</h2>

  TODO
</section>

<section>
  <h2 id="algorithms">Algorithms</h2>

  <section>
    <h3 id="upgrade-algorithm">Upgrade |request| to an <i lang="la">a priori</i>
    authenticated URL as mixed content, if appropriate</h3>

    Note: The Fetch specification will hook into this algorithm to upgrade optionally-blockable
    mixed content to HTTPS.

    Given a <a>Request</a> <var>request</var>, this algorithm will rewrite
    its <a for="request">url</a> if the request is deemed to be optionally-blockable mixed content,
    via the following algorithm:

    <ol>
      <li>
        If one or more of the following conditions is met, return without modifying <var>request</var>:
        <ol>
          <li>
            <var>request</var>'s <a for="request">url</a> is an
            [[mixed-content#a-priori-authenticated-url]].
          </li>
          <li>
            [[mixed-content#categorize-settings-object]] returns "<code>Does Not Restrict Mixed Security
            Contents</code>" when applied to <var>request</var>'s <a for="request">client</a>.
          </li>
          <li>
            <var>request</var>'s <a for="request">mode</a> is <code>CORS</code>.
          </li>
          <li>
            <var>request</var>'s <a for="request">destination</a> is not "<code>image</code>",
            "<code>audio</code>", or "<code>video</code>".
          </li>
          <li>
            <var>request</var>'s <a for="request">destination</a> is "<code>image</code>"
            and <var>request</var>'s <a for="request">initiator</a> is "<code>imageset</code>".
          </li>
        </ol>
      </li>
      <li>
        If <var>request</var>'s <a for="request">url</a>'s <a for="url">scheme</a>
        is <code>http</code>,
        set <var>request</var>'s <a for="request">url</a>'s <a for="url">scheme</a>
        to <code>https</code>, and return.

        Note: Per [[url]], we do not modify the port because it will be set to null when the scheme
        is <code>http</code>, and interpreted as 443 once the scheme is changed
        to <code>https</code>
      </li>
    </ol>

  </section>

  <section>
    <h3 id="modifications">Modifications to existing algorithms</h3>

    Note: This section specifies modifications to existing mixed content algorithms to ignore the
    distinction between optionally-blockable and blockable mixed content, since all
    optionally-blockable mixed content will now be autoupgraded.

    [[mixed-content#should-block-fetch]] should be modified to remove Steps 3, 4, and 5, replacing
    them with a single step "Return <strong>blocked</strong>".

    [[mixed-content#should-block-response]] should be modified to remove Steps 2, 3, and 4,
    replacing them with a single step "Return <strong>blocked</strong>".
</section>

<section>
  <h2 id="integration">Integrations</h2>

  <h3 id="fetch">Modifications to Fetch</h3>

  [[fetch#main-fetch]] should be modified to call [[#upgrade-algorithm]] on <var>request</var>
  between steps 3 and 4. That is, optionally-blockable mixed content should be autoupgraded to HTTPS
  before applying mixed content blocking.

</section>

<section>
  <h2 id="obsolescences">Obsolescences</h2>

  <h3 id="block-all-mixed-content"><code>block-all-mixed-content</code></h3>

  This specification renders the [[mixed-content#block-all-mixed-content]] CSP directive obsolete,
  because all mixed content is now blocked if it can't be autoupgraded.

  Note: The <code>upgrade-insecure-requests</code> ([[upgrade-insecure-requests]]) directive is not
  obsolete because it allows developers to upgrade blockable content. This specification only
  upgrades optionally-blockable content by default.
</section>

<section>
  <h2 id="security-considerations">Security and Privacy Considerations</h2>

  Overall, autoupgrading optionally-blockable mixed content is expected to be security- and
  privacy-positive, by protecting more user traffic from network eavesdropping and tampering.

  There is a risk of introducing a security or privacy issue in a webpage by loading a resource that
  the developer did not intend. For example, suppose that a website includes an innocuous image
  from <code>http://www.example.com/image.jpg</code>, and for some
  reason <code>https://www.example.com/image.jpg</code> redirects to a tracking site. The browser
  will now have introduced a privacy issue without the developer's or user's explicit
  consent. However, these cases are expected to be exceedingly rare. The risk is mitigated by
  autoupgrading only optionally-blockable content, not blockable content as well. Blockable content
  could present more risk, for example the risk of loading an out-of-date and vulnerable JavaScript
  library.
</section>

<section>
  <h2 id="acknowledgements">Acknowledgements</h2>
</section>
